{"version":3,"sources":["webpack:///./src/media/compose.ts","webpack:///./src/media/middleware/base.ts","webpack:///./src/utils/http.ts","webpack:///./src/media/middleware/subreddit.ts","webpack:///./src/media/middleware/youtube.ts","webpack:///./src/media/middleware/youtube-playlist.ts","webpack:///./src/media/middleware/httpHead.ts","webpack:///./src/media/middleware/media.ts","webpack:///./src/media/middleware/html.ts","webpack:///./src/media/middleware/og.js","webpack:///./src/media/middleware/openGraph.ts","webpack:///./src/media/middleware/oembed.ts","webpack:///./src/media/middleware/autoplay.ts","webpack:///./src/media/middleware/microdata.ts","webpack:///./src/media/middleware/imgur.ts","webpack:///./src/media/index.ts"],"names":["media_compose","middleware","Array","isArray","TypeError","mware","match","resolve","ctx","index","dispatch","i","Promise","reject","Error","req","url","err","base","origin","location","[object Object]","next","transformList","Set","prefixHeaders","headers","Object","keys","forEach","name","has","toLowerCase","fetchId","mainFetch","options","startsWith","URL","e","credentials","requestId","handler","event","data","type","window","removeEventListener","resp","payload","addEventListener","postMessage","fetchText","async","body","URL_PATTERN","transformPost","result","id","title","subreddit","xpost","crosspost_parent_list","media","length","parent","getListing","after","urlobj","url_url","paramObj","query","limit","params","utils_url","apiUrl","protocol","hostname","pathname","json","Referer","http","getNextPosts","children","filter","post","stickied","map","isSubreddit","exec","href","isCommentThread","includes","state","reddit","reqState","redditUrl","currentIdx","idx","console","log","error","debug","posts","child","res","hasMore","item","reddit_video","v","duration","oembed","parseItem","youtube_URL_PATTERN","VIDEO_ID_PATTERNS","YouTubeClient","this","instance","youtube","getInstance","getVideoId","metadata","$","isoDuration","attr","metaBroadcast","metaBroadcastEndDate","utils","undefined","metaDescription","description","searchParams","getScrapedMetadata","message","referrer","oEmbed","youtube_playlist_URL_PATTERN","youtube_playlist","isYouTube","isPlaylist","Boolean","ytpl","text","trim","rawLen","split","len","parseInt","isNaN","rawIndex","get","set","toString","httpHead","response","fetchResponse","method","user-agent","referer","httpHeadFailed","code","status","contentType","val","shift","getContentType","responseCode","MIME_MEDIA_TYPES","middleware_media","meta","path_browserify","buildMediaMetadata","middleware_html","host","cheerio","fieldsArray","multiple","property","fieldName","mediaMapperTwitterImage","width","height","alt","mediaMapperTwitterPlayer","stream","mediaMapper","str","parseFloat","mediaSorter","a","b","aRes","aExt","bRes","bExt","Math","max","BAD_VIDEO_TYPES","IGNORE_VIDEO_HOSTNAMES","buildHTMLMetadata","og","ogImageFallback","ogObject","key","attribs","content","push","ogImage","ogImageSecureURL","ogImageURL","ogImageWidth","twitterImageHeight","ogImageType","ogImageHeight","ogImages","zip","sort","ogVideo","ogVideoWidth","ogVideoHeight","ogVideoType","ogVideoDuration","ogVideoSecureURL","videoDuration","ogVideos","twitterImageSrc","twitterImage","twitterImageWidth","twitterImageAlt","twitterImages","twitterPlayer","twitterPlayerWidth","twitterPlayerHeight","twitterPlayerStream","twitterPlayers","allMedia","onlyGetOpenGraphInfo","ogTitle","ogDescription","supportedImageExts","each","elem","indexOf","pop","parse","image","thumbnails","0","useVideo","videoUrl","openGraph","WORDPRESS_OEMBED_PATH","oEmbedJson","link","test","fetchOEmbed","info","html","src","parseOembedUrl","setQueryTrue","prop","autoplay","endsWith","urlObj","search","setAutoplay","microdata","metaDuration","lib","imgur","imageSrc","__webpack_require__","d","__webpack_exports__","resolveMediaUrl","resolveMediaPlaylist","middlewares","createContext","user","finalizeMedia","desc","object","fn"],"mappings":"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","file":"1.app.prod.js","sourcesContent":["import {\n  IMediaMiddleware,\n  IMediaRequest,\n  IMediaResponse,\n  IMediaMiddlewareResolve,\n  IMediaContext\n} from './types'\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\nfunction compose(middleware: IMediaMiddleware[]) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const mware of middleware) {\n    if (typeof mware.match !== 'function' || typeof mware.resolve !== 'function') {\n      throw new TypeError('Middleware must be composed of functions!')\n    }\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n  return function(ctx: IMediaContext) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch(i: number): PromiseLike<IMediaResponse | void> {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let mware: IMediaMiddleware | undefined = middleware[i]\n      if (!mware) return Promise.resolve()\n\n      if (!mware.match(ctx.req.url, ctx)) {\n        return Promise.resolve(dispatch(i + 1))\n      }\n\n      try {\n        return Promise.resolve<any>(\n          mware.resolve(ctx, function next() {\n            return dispatch(i + 1)\n          })\n        )\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n\nexport default compose\n","import { IMediaMiddleware } from '../types'\nimport { APP_WEBSITE } from '../../constants/http'\n\nconst mware: IMediaMiddleware = {\n  match({ origin }) {\n    return origin === location.origin\n  },\n\n  resolve(ctx, next) {\n    throw new Error('Unable to request Metastream app link')\n  }\n}\n\nexport default mware\n","import { CoreOptions, RequestResponse } from 'request'\n\ntype FetchResponse = Response & {\n  body: any\n  headers: { [key: string]: string }\n}\n\ninterface FetchOptions extends RequestInit {\n  timeout?: number\n}\n\nconst transformList = new Set(['user-agent', 'referer'])\nconst prefixHeaders = (headers: any) => {\n  if (typeof headers === 'object') {\n    headers = { ...headers }\n    // Prefix reserved headers to be fixed in the extension background script\n    Object.keys(headers).forEach(name => {\n      if (transformList.has(name.toLowerCase())) {\n        headers[`X-Metastream-${name}`] = headers[name]\n      }\n    })\n  }\n  return headers\n}\n\nlet fetchId = 0\nconst mainFetch = (url: string, options: FetchOptions = {}): Promise<FetchResponse> => {\n  return new Promise((resolve, reject) => {\n    if (url.startsWith('//')) {\n      url = `https:${url}`\n    }\n\n    try {\n      new URL(url)\n    } catch (e) {\n      reject(e)\n      return\n    }\n\n    options = {\n      credentials: 'omit', // ignore cookies\n      ...options,\n      headers: prefixHeaders(options.headers)\n    }\n\n    const requestId = fetchId++\n\n    const handler = (event: MessageEvent) => {\n      const { data } = event\n      if (typeof data !== 'object') return\n      if (data.type !== `metastream-fetch-response${requestId}`) return\n\n      window.removeEventListener('message', handler, false)\n\n      const { err, resp } = data.payload\n\n      if (err) {\n        reject(err)\n        return\n      }\n\n      resolve(resp)\n    }\n\n    window.addEventListener('message', handler, false)\n    window.postMessage(\n      { type: 'metastream-fetch', payload: { requestId, url, options } },\n      location.origin\n    )\n  })\n}\n\nexport const fetchText = async <T = string>(\n  url: string,\n  options?: RequestInit\n): Promise<[T, FetchResponse]> => {\n  const resp = await mainFetch(url, options)\n  return [resp.body, resp]\n}\n\nexport const fetchResponse = async (url: string, options?: RequestInit): Promise<FetchResponse> => {\n  const resp = await mainFetch(url, options)\n  return resp\n}\n","import { parse } from 'url'\nimport { encodeQueryParams } from 'utils/url'\nimport { IMediaMiddleware, MediaType, IMediaContext } from '../types'\nimport { fetchText } from 'utils/http'\nimport { MEDIA_REFERRER } from 'constants/http'\n\n// https://www.reddit.com/dev/api/\n\nconst enum ObjectType {\n  Comment = 't1',\n  Account = 't2',\n  Link = 't3',\n  Message = 't4',\n  Subreddit = 't5',\n  Award = 't6'\n}\n\nconst URL_PATTERN = /reddit\\.com\\/r\\/([^\\s/]+)\\/?/i\nconst API_LIMIT = 5\n\nconst transformPost = ({ data }: any) => {\n  let result: any = {\n    id: data.id,\n    url: data.url,\n    title: `${data.title} - /r/${data.subreddit}`\n  }\n\n  const xpost = data.crosspost_parent_list\n\n  // TODO: secure_media_embed\n  if (data.media) {\n    result.media = data.media\n  }\n\n  if (xpost && xpost.length > 0) {\n    const parent = xpost[0]\n\n    if (parent.url) {\n      result.url = parent.url\n    }\n\n    if (parent.media) {\n      result.media = parent.media\n    }\n  }\n\n  return result\n}\n\nconst getListing = async (url: string, after?: string) => {\n  const urlobj = parse(url, true)\n\n  const paramObj: { [key: string]: string | number } = {\n    ...urlobj.query,\n    limit: API_LIMIT\n  }\n\n  if (after) {\n    paramObj.after = after\n  }\n\n  const params = encodeQueryParams(paramObj)\n\n  // TODO: Keep GET params for filtering\n  // TODO: Pick up from previous playlist state\n  const apiUrl = `${urlobj.protocol}//${urlobj.hostname}${urlobj.pathname}.json?${params}`\n\n  const [json] = await fetchText<any>(apiUrl, {\n    headers: {\n      Referer: MEDIA_REFERRER\n    }\n  })\n\n  return json\n}\n\nconst getNextPosts = (json: any) => {\n  const posts = (json.data.children as any[]).filter(post => !post.data.stickied).map(transformPost)\n  return posts\n}\n\nconst parseItem = (ctx: IMediaContext, item: any): any => {\n  ctx.res.title = item.title\n\n  // Overwrite request url with subreddit post\n  const url = new URL(item.url)\n  if (url && url.href) {\n    ctx.req.url = url\n  }\n\n  const { media } = item\n  if (media) {\n    if (media.reddit_video) {\n      const v = media.reddit_video\n\n      if (url && url.href) ctx.res.url = url.href\n\n      const duration = v.duration * 1000\n      if (duration) ctx.res.duration = duration\n\n      return true\n    } else if (media.oembed) {\n      // Defer parse to oembed middleware\n      // ctx.state.oEmbedJson = media.oembed\n      return false\n    }\n  }\n\n  return false\n}\n\nconst mware: IMediaMiddleware = {\n  match(url, ctx) {\n    const isSubreddit = !!URL_PATTERN.exec(url.href)\n    const isCommentThread = url.pathname ? url.pathname.includes('/comments/') : false\n    return (isSubreddit && !isCommentThread) || !!(ctx.req.state && ctx.req.state.reddit)\n  },\n\n  async resolve(ctx, next) {\n    const reqState = ctx.req.state\n\n    let redditUrl\n    let children: any[]\n    let after\n    let currentIdx\n\n    // TODO: filter for API listings (/hot, /new, etc.)\n    // https://www.reddit.com/dev/api/#section_listings\n    if (reqState && reqState.reddit) {\n      redditUrl = reqState.reddit.href\n      children = reqState.reddit.children\n      after = reqState.reddit.after\n      currentIdx = reqState.reddit.idx\n    } else {\n      redditUrl = ctx.req.url.href\n      const json = await getListing(redditUrl)\n      console.log('Subreddit JSON', json)\n\n      if (json.error) {\n        console.debug('Error fetching subreddit posts')\n        return next()\n      }\n\n      const posts = getNextPosts(json)\n\n      if (posts.length === 0) {\n        return next()\n      }\n\n      children = posts\n      after = json.data.after\n      currentIdx = -1\n    }\n\n    let idx = currentIdx + 1\n    let child = children[idx]\n\n    if (!child) {\n      const json = await getListing(reqState!.reddit.href, reqState!.reddit.after)\n      const posts = getNextPosts(json)\n\n      if (posts.length === 0) {\n        return next()\n      }\n\n      idx = 0\n      children = posts\n      child = children[idx]\n      after = json.data.after\n\n      if (!child) {\n        return\n      }\n    }\n\n    // Save pagination info for resolving next playlist item\n    ctx.res.type = MediaType.Playlist\n    ctx.res.hasMore = true\n    ctx.res.state = {\n      ...ctx.res.state,\n      reddit: {\n        ...(reqState || {}).reddit,\n        href: redditUrl,\n        idx,\n        children,\n        after\n      }\n    }\n\n    if (!parseItem(ctx, child)) {\n      await next()\n\n      let title = child.title || ctx.res.title\n      ctx.res.title = title\n      return ctx.res\n    }\n  }\n}\n\nexport default mware\n","import { IMediaMiddleware, IMediaResponse } from '../types'\nimport { mergeMetadata, parseHtmlDescription, parseISO8601 } from '../utils'\n\nconst URL_PATTERN = /youtu\\.?be(?:.com)?/i\n\n// TODO: https://www.youtube.com/attribution_link?a=ShEHdkiTDq4&u=%2Fwatch%3Fv%3Dm-6zjXLPRHg%26feature%3Dshare\nconst VIDEO_ID_PATTERNS = [\n  /youtu\\.be\\/([^#\\&\\?]{11})/, // youtu.be/<id>\n  /\\?v=([^#\\&\\?]{11})/, // ?v=<id>\n  /\\&v=([^#\\&\\?]{11})/, // &v=<id>\n  /embed\\/([^#\\&\\?]{11})/, // embed/<id>\n  /\\/v\\/([^#\\&\\?]{11})/ // /v/<id>\n]\n\nclass YouTubeClient {\n  static getInstance(): YouTubeClient {\n    if (!this.instance) {\n      this.instance = new YouTubeClient()\n    }\n    return this.instance\n  }\n\n  private static instance: YouTubeClient\n\n  getVideoId(url: string): string | null {\n    let match\n\n    for (let i = 0; i < VIDEO_ID_PATTERNS.length; i++) {\n      match = VIDEO_ID_PATTERNS[i].exec(url)\n      if (match) {\n        break\n      }\n    }\n\n    return match ? match[1] : null\n  }\n}\n\nasync function getScrapedMetadata(url: URL, $: CheerioStatic): Promise<Partial<IMediaResponse>> {\n  const metaDuration = $('meta[itemprop=duration]')\n  const isoDuration = metaDuration.attr('content')\n\n  const metaBroadcast = $('meta[itemprop=isLiveBroadcast]')\n  const metaBroadcastEndDate = $('meta[itemprop=endDate]')\n  const isLiveBroadcast =\n    (metaBroadcast.attr('content') || '').toLowerCase() === 'true' && !metaBroadcastEndDate\n\n  let duration\n\n  if (isLiveBroadcast) {\n    duration = 0\n  } else {\n    duration = isoDuration ? parseISO8601(isoDuration) * 1000 : undefined\n  }\n\n  const metaDescription = $('#eow-description')\n  const description =\n    metaDescription.length === 1 ? parseHtmlDescription(metaDescription) : undefined\n\n  if (url.searchParams.has('t')) {\n    // TODO: parse '1h2m3s' format\n    // startTime = parseHms(query.t)\n  }\n\n  return {\n    duration,\n    description\n  }\n}\n\nconst mware: IMediaMiddleware = {\n  match(url) {\n    const { hostname = '', href = '' } = url\n    return !!URL_PATTERN.exec(hostname) && !!YouTubeClient.getInstance().getVideoId(href)\n  },\n\n  async resolve(ctx, next) {\n    let metadata\n\n    try {\n      metadata = await getScrapedMetadata(ctx.req.url, ctx.state.$!)\n    } catch (e) {\n      console.error('YouTube request failed', e.message)\n      return next()\n    }\n\n    mergeMetadata(ctx.res, metadata)\n\n    // Bypass restricted embed playback\n    ctx.res.state.referrer = true\n\n    // Disable oEmbed for playlists\n    ctx.state.oEmbed = false\n\n    return next()\n  }\n}\n\nexport default mware\n","import { Url, parse } from 'url'\nimport { buildUrl, encodeQueryParams } from 'utils/url'\nimport {\n  MediaThumbnailSize,\n  IMediaMiddleware,\n  IMediaRequest,\n  IMediaResponse,\n  MediaType,\n  IMediaContext\n} from '../types'\n\nconst URL_PATTERN = /youtu\\.?be(?:.com)?/i\n\nconst PLAYLIST_LEN_PATTERN = /\"playlist_length\":\"(\\d+)\"/i\n\ninterface IYouTubePlaylistState {\n  title: string\n  index: number\n  length: number\n}\n\nconst mware: IMediaMiddleware = {\n  match(url, ctx) {\n    const isYouTube = !!URL_PATTERN.exec(url.href)\n    const isPlaylist = url.searchParams.has('list')\n    return (isYouTube && isPlaylist) || Boolean(ctx.req.state && ctx.req.state.ytpl)\n  },\n\n  async resolve(ctx, next) {\n    const { state } = ctx.req\n    const ytpl: IYouTubePlaylistState = (state && state.ytpl) || {}\n\n    const isInitialRequest = typeof ytpl.index === 'undefined'\n\n    if (isInitialRequest) {\n      await next()\n\n      const { res } = ctx\n\n      const { body, $ } = ctx.state\n      if (!body || !$) return\n\n      const title = $('.playlist-title').text() || res.title\n      ytpl.title = (title || 'YouTube Playlist').trim()\n\n      const rawLen = $('#playlist-length')\n        .text()\n        .split(' ')[0]\n      const len = parseInt(rawLen, 10)\n      if (isNaN(len)) return\n\n      ytpl.length = len\n\n      const rawIndex = $('li.currently-playing').data('index')\n      const params = ctx.req.url.searchParams\n      const index = rawIndex || params.get('index') || '0'\n      ytpl.index = parseInt(index, 10) || 0\n\n      ctx.res.state.ytpl = ytpl\n    } else {\n      ytpl.index++\n\n      const url = ctx.req.url\n      url.pathname = '/embed/videoseries'\n      url.searchParams.set('index', `${ytpl.index}`)\n      ctx.res.url = url.toString()\n    }\n\n    let { index, length, title } = ytpl\n\n    ctx.res.title = title\n    ctx.res.state = { ...ctx.req.state, ytpl, referrer: true }\n    ctx.res.hasMore = index < length - 1\n\n    return ctx.res\n  }\n}\n\nexport default mware\n","import { MediaThumbnailSize, IMediaRequest, IMediaMiddleware, IMediaResponse } from '../types'\nimport { fetchResponse } from 'utils/http'\nimport { Url } from 'url'\nimport { basename } from 'path'\nimport { MEDIA_USER_AGENT } from 'constants/http'\n\n/** https://www.w3.org/Protocols/rfc1341/4_Content-Type.html */\nconst getContentType = (val: string | undefined) =>\n  val ? (val.split('/').shift() || '').toLowerCase() : ''\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }: URL) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n\n    // Request HEAD response to check MIME type\n    let response\n\n    try {\n      response = await fetchResponse(url.href, {\n        method: 'HEAD',\n        headers: {\n          'user-agent': MEDIA_USER_AGENT,\n          referer: url.href // prevent hotlink blocking\n        }\n      })\n    } catch {\n      ctx.state.httpHeadFailed = true\n      return next()\n    }\n\n    const code = response.status || 200\n    // if (code >= 400) {\n    //   return;\n    // }\n\n    let contentType = response.headers['content-type']\n    contentType = Array.isArray(contentType) ? contentType[0] : contentType\n    const type = getContentType(contentType)\n\n    ctx.state.responseCode = code\n    ctx.state.contentType = contentType\n    ctx.state.type = type\n\n    return next()\n  }\n}\n\nexport default mware\n","import { Url } from 'url'\nimport { basename } from 'path'\n\nimport { IMediaMiddleware, IMediaResponse } from '../types'\n\nconst MIME_MEDIA_TYPES = new Set(['audio', 'image', 'video'])\n\nfunction buildMediaMetadata(url: URL): Partial<IMediaResponse> {\n  // TODO: get ID3 metadata from MP3s\n  return {\n    url: url.href!,\n    title: basename(url.pathname || url.href!)\n  }\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  resolve({ req, res, state }, next) {\n    const { url } = req\n    const { type } = state\n\n    // Avoid GET requests to media\n    if (type && MIME_MEDIA_TYPES.has(type)) {\n      const meta = buildMediaMetadata(url)\n      res.url = meta.url || res.url\n      res.title = res.title || meta.title\n      return res\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\nimport { IMediaMiddleware } from '../types'\nimport { fetchText } from 'utils/http'\nimport { MEDIA_USER_AGENT } from 'constants/http'\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n\n    // Skip if HEAD request fails to avoid fetching huge blobs of data\n    if (ctx.state.httpHeadFailed) {\n      return next()\n    }\n\n    let text\n\n    try {\n      const result = await fetchText(url.href, {\n        headers: {\n          'user-agent': MEDIA_USER_AGENT,\n          host: url.host\n        }\n      })\n      text = result[0]\n    } catch {\n      return next()\n    }\n\n    ctx.state.body = text\n    const $ = (ctx.state.$ = load(text))\n\n    // prettier-ignore\n    ctx.res.title = $('title').text().trim() || ctx.res.title\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\nimport { zip } from 'lodash-es'\n\nconst fieldsArray = [\n  {\n    multiple: false,\n    property: 'og:title',\n    fieldName: 'ogTitle'\n  },\n  {\n    multiple: false,\n    property: 'og:type',\n    fieldName: 'ogType'\n  },\n  {\n    multiple: true,\n    property: 'og:image',\n    fieldName: 'ogImage'\n  },\n  {\n    multiple: true,\n    property: 'og:image:url',\n    fieldName: 'ogImageURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:secure_url',\n    fieldName: 'ogImageSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:width',\n    fieldName: 'ogImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:image:height',\n    fieldName: 'ogImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:image:type',\n    fieldName: 'ogImageType'\n  },\n  {\n    multiple: false,\n    property: 'og:url',\n    fieldName: 'ogUrl'\n  },\n  {\n    multiple: false,\n    property: 'og:audio',\n    fieldName: 'ogAudio'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:url',\n    fieldName: 'ogAudioURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:secure_url',\n    fieldName: 'ogAudioSecureURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:type',\n    fieldName: 'ogAudioType'\n  },\n  {\n    multiple: false,\n    property: 'og:description',\n    fieldName: 'ogDescription'\n  },\n  {\n    multiple: false,\n    property: 'og:determiner',\n    fieldName: 'ogDeterminer'\n  },\n  {\n    multiple: false,\n    property: 'og:locale',\n    fieldName: 'ogLocale'\n  },\n  {\n    multiple: false,\n    property: 'og:locale:alternate',\n    fieldName: 'ogLocaleAlternate'\n  },\n  {\n    multiple: false,\n    property: 'og:site_name',\n    fieldName: 'ogSiteName'\n  },\n  {\n    multiple: true,\n    property: 'og:video',\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:url', // An alternative to 'og:video'\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:secure_url',\n    fieldName: 'ogVideoSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:video:width',\n    fieldName: 'ogVideoWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:video:height',\n    fieldName: 'ogVideoHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:video:type',\n    fieldName: 'ogVideoType'\n  },\n  // This format is wrong, but was seen on vk.com\n  {\n    multiple: true,\n    property: 'og:video:duration',\n    fieldName: 'ogVideoDuration'\n  },\n  {\n    multiple: true,\n    property: 'video:duration',\n    fieldName: 'videoDuration'\n  },\n  {\n    multiple: false,\n    property: 'twitter:card',\n    fieldName: 'twitterCard'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site',\n    fieldName: 'twitterSite'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site:id',\n    fieldName: 'twitterSiteId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator',\n    fieldName: 'twitterCreator'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator:id',\n    fieldName: 'twitterCreatorId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:title',\n    fieldName: 'twitterTitle'\n  },\n  {\n    multiple: false,\n    property: 'twitter:description',\n    fieldName: 'twitterDescription'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image',\n    fieldName: 'twitterImage'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:height',\n    fieldName: 'twitterImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:width',\n    fieldName: 'twitterImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:src',\n    fieldName: 'twitterImageSrc'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:alt',\n    fieldName: 'twitterImageAlt'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player',\n    fieldName: 'twitterPlayer'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:width',\n    fieldName: 'twitterPlayerWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:height',\n    fieldName: 'twitterPlayerHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:stream',\n    fieldName: 'twitterPlayerStream'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:iphone',\n    fieldName: 'twitterAppNameiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:iphone',\n    fieldName: 'twitterAppIdiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:iphone',\n    fieldName: 'twitterAppUrliPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:ipad',\n    fieldName: 'twitterAppNameiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:ipad',\n    fieldName: 'twitterAppIdiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:ipad',\n    fieldName: 'twitterAppUrliPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:googleplay',\n    fieldName: 'twitterAppNameGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:googleplay',\n    fieldName: 'twitterAppIdGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:googleplay',\n    fieldName: 'twitterAppUrlGooglePlay'\n  }\n]\n\nvar parseNumbers = function(str) {\n  if (!isNaN(str)) {\n    str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str)\n  }\n  return str\n}\n\nvar mediaMapperTwitterImage = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    alt: item[3]\n  }\n}\n\nvar mediaMapperTwitterPlayer = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    stream: item[3]\n  }\n}\n\nvar mediaMapper = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    type: item[3],\n    duration: parseNumbers(item[4])\n  }\n}\n\nvar mediaSorter = function(a, b) {\n  if (!(a.url && b.url)) {\n    return 0\n  }\n\n  var aRes = a.url.match(/\\.(\\w{2,5})$/),\n    aExt = (aRes && aRes[1].toLowerCase()) || null\n  var bRes = b.url.match(/\\.(\\w{2,5})$/),\n    bExt = (bRes && bRes[1].toLowerCase()) || null\n\n  if (aExt === 'gif' && bExt !== 'gif') {\n    return -1\n  } else if (aExt !== 'gif' && bExt === 'gif') {\n    return 1\n  } else {\n    return Math.max(b.width, b.height) - Math.max(a.width, a.height)\n  }\n}\n\n/*\n * getOG - scrape that url!\n * @param string url - the url we want to scrape\n * @param function callback\n */\nexport function parse(body, options) {\n  const ogImageFallback = options.ogImageFallback === undefined ? true : options.ogImageFallback\n\n  let $ = load(body),\n    meta = $('meta'),\n    keys = Object.keys(meta)\n\n  let ogObject = {}\n\n  keys.forEach(function(key) {\n    if (!(meta[key].attribs && (meta[key].attribs.property || meta[key].attribs.name))) {\n      return\n    }\n    var property = meta[key].attribs.property || meta[key].attribs.name,\n      content = meta[key].attribs.content\n    fieldsArray.forEach(function(item) {\n      if (property === item.property) {\n        if (!item.multiple) {\n          ogObject[item.fieldName] = content\n        } else if (!ogObject[item.fieldName]) {\n          ogObject[item.fieldName] = [content]\n        } else if (Array.isArray(ogObject[item.fieldName])) {\n          ogObject[item.fieldName].push(content)\n        }\n      }\n    })\n  })\n\n  // set the ogImage or fallback to ogImageURL or ogImageSecureURL\n  ogObject.ogImage = ogObject.ogImageSecureURL\n    ? ogObject.ogImageSecureURL\n    : ogObject.ogImage\n    ? ogObject.ogImage\n    : ogObject.ogImageURL\n    ? ogObject.ogImageURL\n    : []\n  if (!ogObject.ogImage || !ogObject.ogImage.length) {\n    delete ogObject['ogImage']\n  }\n\n  /* Combine image/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogImage ||\n    ogObject.ogImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.ogImageType\n  ) {\n    ogObject.ogImage = ogObject.ogImage ? ogObject.ogImage : [null]\n    ogObject.ogImageWidth = ogObject.ogImageWidth ? ogObject.ogImageWidth : [null]\n    ogObject.ogImageHeight = ogObject.ogImageHeight ? ogObject.ogImageHeight : [null]\n    ogObject.ogImageType = ogObject.ogImageType ? ogObject.ogImageType : [null]\n  }\n  var ogImages = zip(\n    ogObject.ogImage,\n    ogObject.ogImageWidth,\n    ogObject.ogImageHeight,\n    ogObject.ogImageType\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine video/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogVideo ||\n    ogObject.ogVideoWidth ||\n    ogObject.ogVideoHeight ||\n    ogObject.ogVideoType ||\n    ogObject.ogVideoDuration\n  ) {\n    ogObject.ogVideo = ogObject.ogVideo ? ogObject.ogVideo : [null]\n    ogObject.ogVideo = ogObject.ogVideoSecureURL ? ogObject.ogVideoSecureURL : ogObject.ogVideo\n    ogObject.ogVideoWidth = ogObject.ogVideoWidth ? ogObject.ogVideoWidth : [null]\n    ogObject.ogVideoHeight = ogObject.ogVideoHeight ? ogObject.ogVideoHeight : [null]\n    ogObject.ogVideoType = ogObject.ogVideoType ? ogObject.ogVideoType : [null]\n    ogObject.ogVideoDuration = ogObject.videoDuration || ogObject.ogVideoDuration || [null]\n  }\n  var ogVideos = zip(\n    ogObject.ogVideo,\n    ogObject.ogVideoWidth,\n    ogObject.ogVideoHeight,\n    ogObject.ogVideoType,\n    ogObject.ogVideoDuration\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine twitter image/width/height/alt\n      and sort for priority */\n  if (\n    ogObject.twitterImageSrc ||\n    ogObject.twitterImage ||\n    ogObject.twitterImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.twitterImageAlt\n  ) {\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : ogObject.twitterImageSrc\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : [null]\n    ogObject.twitterImageWidth = ogObject.twitterImageWidth ? ogObject.twitterImageWidth : [null]\n    ogObject.twitterImageHeight = ogObject.twitterImageHeight ? ogObject.twitterImageHeight : [null]\n    ogObject.twitterImageAlt = ogObject.twitterImageAlt ? ogObject.twitterImageAlt : [null]\n  }\n  var twitterImages = zip(\n    ogObject.twitterImage,\n    ogObject.twitterImageWidth,\n    ogObject.twitterImageHeight,\n    ogObject.twitterImageAlt\n  )\n    .map(mediaMapperTwitterImage)\n    .sort(mediaSorter)\n\n  /* Combine twitter player/width/height/stream\n      and sort for priority */\n  if (\n    ogObject.twitterPlayer ||\n    ogObject.twitterPlayerWidth ||\n    ogObject.twitterPlayerHeight ||\n    ogObject.twitterPlayerStream\n  ) {\n    ogObject.twitterPlayer = ogObject.twitterPlayer ? ogObject.twitterPlayer : [null]\n    ogObject.twitterPlayerWidth = ogObject.twitterPlayerWidth ? ogObject.twitterPlayerWidth : [null]\n    ogObject.twitterPlayerHeight = ogObject.twitterPlayerHeight\n      ? ogObject.twitterPlayerHeight\n      : [null]\n    ogObject.twitterPlayerStream = ogObject.twitterPlayerStream\n      ? ogObject.twitterPlayerStream\n      : [null]\n  }\n  var twitterPlayers = zip(\n    ogObject.twitterPlayer,\n    ogObject.twitterPlayerWidth,\n    ogObject.twitterPlayerHeight,\n    ogObject.twitterPlayerStream\n  )\n    .map(mediaMapperTwitterPlayer)\n    .sort(mediaSorter)\n\n  // Delete temporary fields\n  fieldsArray\n    .filter(function(item) {\n      return item.multiple\n    })\n    .forEach(function(item) {\n      delete ogObject[item.fieldName]\n    })\n\n  // Select the best image\n  if (ogImages.length) {\n    if (options.allMedia) {\n      ogObject.ogImage = ogImages\n    } else {\n      ogObject.ogImage = ogImages[0]\n    }\n  }\n\n  // Select the best video\n  if (ogVideos.length) {\n    if (options.allMedia) {\n      ogObject.ogVideo = ogVideos\n    } else {\n      ogObject.ogVideo = ogVideos[0]\n    }\n  }\n\n  // Select the best twitter image\n  if (twitterImages.length) {\n    if (options.allMedia) {\n      ogObject.twitterImage = twitterImages\n    } else {\n      ogObject.twitterImage = twitterImages[0]\n    }\n  }\n\n  // Select the best player\n  if (twitterPlayers.length) {\n    if (options.allMedia) {\n      ogObject.twitterPlayer = twitterPlayers\n    } else {\n      ogObject.twitterPlayer = twitterPlayers[0]\n    }\n  }\n\n  // Check for 'only get open graph info'\n  if (!options.onlyGetOpenGraphInfo) {\n    // Get title tag if og title was not provided\n    if (!ogObject.ogTitle && $('head > title').text() && $('head > title').text().length > 0) {\n      ogObject.ogTitle = $('head > title').text()\n    }\n    // Get meta description tag if og description was not provided\n    if (\n      !ogObject.ogDescription &&\n      $('head > meta[name=\"description\"]').attr('content') &&\n      $('head > meta[name=\"description\"]').attr('content').length > 0\n    ) {\n      ogObject.ogDescription = $('head > meta[name=\"description\"]').attr('content')\n    }\n    // Get first image as og:image if there is no og:image tag.\n    if (!ogObject.ogImage && ogImageFallback) {\n      var supportedImageExts = ['jpg', 'jpeg', 'png']\n      $('img').each(function(i, elem) {\n        if (\n          $(elem).attr('src') &&\n          $(elem).attr('src').length > 0 &&\n          supportedImageExts.indexOf(\n            $(elem)\n              .attr('src')\n              .split('.')\n              .pop()\n          ) !== -1\n        ) {\n          ogObject.ogImage = {\n            url: $(elem).attr('src')\n          }\n          return false\n        }\n      })\n    }\n  }\n\n  return ogObject\n}\n","import { isUrl } from 'utils/url'\n\nimport { MediaThumbnailSize, IMediaMiddleware, IMediaResponse } from '../types'\nimport { parse } from './og'\nimport { mergeMetadata } from '../utils'\n\n/** Bad video types to not use. */\nconst BAD_VIDEO_TYPES = new Set(['application/x-shockwave-flash'])\n\n/** Disable using opengraph videos on specific websites. */\nconst IGNORE_VIDEO_HOSTNAMES = new Set([\n  'www.netflix.com' // ignore series trailer\n])\n\nfunction buildHTMLMetadata(url: URL, body: string): Partial<IMediaResponse> {\n  const og = parse(body, {})\n  console.log('og', og)\n  const { ogTitle: title, ogImage: image, ogDescription: description } = og\n\n  const thumbnails = image\n    ? {\n        [MediaThumbnailSize.Default]: image.url\n      }\n    : undefined\n\n  const meta: Partial<IMediaResponse> = {\n    url: url.href!,\n    title,\n    thumbnails,\n    description\n  }\n\n  let useVideo = !IGNORE_VIDEO_HOSTNAMES.has(url.hostname)\n\n  if (useVideo && og.ogVideo) {\n    const type = og.ogVideo.type\n    const videoUrl = og.ogVideo.url\n\n    const hasValidType = type ? !BAD_VIDEO_TYPES.has(type) : true\n    useVideo = hasValidType && videoUrl && isUrl(videoUrl)\n\n    if (useVideo) meta.url = videoUrl\n    if (og.ogVideo.duration) meta.duration = og.ogVideo.duration * 1000\n  }\n\n  return meta\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n    const { $, body } = ctx.state\n\n    if ($ && body) {\n      const meta = buildHTMLMetadata(url, body)\n      mergeMetadata(ctx.res, meta)\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\nimport { IMediaMiddleware } from '../types'\nimport { fetchText } from 'utils/http'\nimport { Url } from 'url'\nimport { MEDIA_USER_AGENT } from 'constants/http'\nimport { mergeMetadata } from '../utils'\n\nconst WORDPRESS_OEMBED_PATH = /\\/wp-json\\/oembed\\/.*?\\/embed/i\n\nasync function fetchOEmbed(url: string) {\n  const [json] = await fetchText(url, {\n    headers: {\n      'user-agent': MEDIA_USER_AGENT\n    }\n  })\n\n  return json as any\n}\n\nfunction parseOembedUrl(json: any) {\n  if (typeof json.html === 'string') {\n    // Decode html entities if needed\n    const html = json.html.startsWith('&lt;') ? load(json.html)('body').text() : json.html\n    const $ = load(html)\n    let src = $('iframe').attr('src')\n\n    if (src) {\n      return src.startsWith('//') ? `https:${src}` : src\n    }\n  }\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    if (typeof ctx.state.oEmbed === 'boolean' && !ctx.state.oEmbed) {\n      return next()\n    }\n\n    const { url } = ctx.req\n\n    let json\n\n    if (ctx.state.oEmbedJson) {\n      json = ctx.state.oEmbedJson\n    } else if (ctx.state.$) {\n      const { $ } = ctx.state\n      const link = $(`link[type='text/json+oembed'], link[type='application/json+oembed']`).attr(\n        'href'\n      )\n\n      if (\n        link &&\n        // Wordpress embeds are super generic\n        !WORDPRESS_OEMBED_PATH.test(link)\n      ) {\n        json = await fetchOEmbed(link)\n      }\n    }\n\n    if (json) {\n      console.info('oembed', json)\n      const src = parseOembedUrl(json)\n\n      const meta = {\n        url: src,\n        description: json.description\n      }\n\n      mergeMetadata(ctx.res, meta)\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { IMediaMiddleware } from '../types'\nimport { Url, parse, format } from 'url'\nimport { encodeQueryParams } from 'utils/url'\n\nconst setQueryTrue = (prop: string, query: any) => {\n  if (!!query[prop]) {\n    query[prop] = 'true'\n    return true\n  }\n}\n\n/** Set autoplay query param to true */\nconst setAutoplay = (url: string) => {\n  const urlObj = parse(url, true)\n  const { query } = urlObj\n\n  if (!(setQueryTrue('autoplay', query) || setQueryTrue('auto_play', query))) {\n    ;['autoplay', 'auto_play'].forEach(prop => {\n      query[prop] = 'true'\n    })\n  }\n\n  urlObj.search = encodeQueryParams(query)\n\n  return format(urlObj)\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol, host }) {\n    // BUG: server returns Access Denied\n    if (host && host.indexOf('redd.it') > -1) {\n      return false\n    }\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.res\n\n    // TODO: use mime-type instead of extension\n    // need a way to compose httpHead/media mware after microdata changes url\n    const isMedia = url ? url.endsWith('mp4') : false\n\n    if (!isMedia) {\n      ctx.res.url = setAutoplay(url)\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\n\nimport { IMediaMiddleware } from '../types'\nimport { parse, toSeconds } from 'iso8601-duration'\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n    const { $ } = ctx.state\n\n    // TODO: clean this up and make it more robust\n    if ($) {\n      const noscript = $(`noscript`)\n\n      noscript.each(function(idx: number, elem: any) {\n        const node = ctx.state.$!(elem)\n        const text = node.text()\n\n        if (text.indexOf('schema.org') === -1) {\n          return\n        }\n\n        const $ = load(text)\n\n        const metaDuration = $(`meta[itemprop='duration']`).attr('content')\n        if (metaDuration) {\n          const duration = toSeconds(parse(metaDuration)) * 1000\n\n          if (duration && !isNaN(duration)) {\n            ctx.res.duration = duration\n          }\n        }\n      })\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { IMediaMiddleware } from '../types'\n\nconst mware: IMediaMiddleware = {\n  match(url) {\n    const { hostname = '' } = url\n    return hostname.endsWith('imgur.com')\n  },\n\n  async resolve(ctx, next) {\n    const { $ } = ctx.state\n\n    if ($) {\n      const title = $('title')\n        .text()\n        .trim()\n      const imageSrc = $('link[rel=image_src]').attr('href')\n      const isAlbum = title.endsWith('Album on Imgur')\n\n      if (!isAlbum && imageSrc) {\n        await next()\n        ctx.res.url = imageSrc\n        return ctx.res\n      }\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { cleanObject } from 'utils/object'\nimport compose from './compose'\n\nimport { IMediaMiddleware, IMediaRequest, IMediaResponse, IMediaContext, MediaType } from './types'\n\nimport baseMware from './middleware/base'\nimport subredditMware from './middleware/subreddit'\nimport youTubeMware from './middleware/youtube'\nimport youTubePlaylistMware from './middleware/youtube-playlist'\nimport httpHeadMware from './middleware/httpHead'\nimport mediaMware from './middleware/media'\nimport htmlMware from './middleware/html'\nimport openGraphMware from './middleware/openGraph'\nimport oEmbedMware from './middleware/oembed'\nimport autoplayMware from './middleware/autoplay'\nimport microdataMware from './middleware/microdata'\nimport imgurMware from './middleware/imgur'\n\nimport { IMediaItem } from 'lobby/reducers/mediaPlayer'\n\n// prettier-ignore\nconst middlewares: IMediaMiddleware[] = [\n  baseMware,\n\n  subredditMware,\n  youTubePlaylistMware,\n\n  httpHeadMware,\n  mediaMware,\n  htmlMware,\n\n  youTubeMware,\n  imgurMware,\n\n  openGraphMware,\n  oEmbedMware,\n  microdataMware,\n  autoplayMware\n];\n\ntype MediaUrl = URL\n\nconst createContext = (url: MediaUrl) => {\n  const req: IMediaRequest = {\n    type: MediaType.Item,\n    url,\n\n    // TODO: add user info for logging middleware\n    user: null\n  }\n\n  const res: IMediaResponse = {\n    type: MediaType.Item,\n    url: url.href,\n    state: {}\n  }\n\n  const ctx: IMediaContext = {\n    req,\n    res,\n    state: {}\n  }\n\n  return ctx\n}\n\nconst finalizeMedia = (media: IMediaResponse) => {\n  if (media.description) {\n    const desc = media.description.trim()\n    media.description = desc || undefined\n  }\n  return cleanObject(media)\n}\n\nexport const resolveMediaUrl = async (url: string): Promise<Readonly<IMediaResponse> | null> => {\n  const urlObj: MediaUrl = new URL(url)\n  if (!urlObj.href) {\n    return null\n  }\n\n  const ctx = createContext(urlObj)\n\n  const fn = compose(middlewares)\n  const result = (await fn(ctx)) || ctx.res\n  console.debug('Resolved media', ctx)\n  return finalizeMedia(result)\n}\n\nexport const resolveMediaPlaylist = async (\n  media: IMediaItem\n): Promise<Readonly<IMediaResponse> | null> => {\n  const urlObj: MediaUrl = new URL(media.url)\n  if (!urlObj.href) {\n    return null\n  }\n\n  const ctx = createContext(urlObj)\n\n  // Transfer old state to new request\n  ctx.req = {\n    ...ctx.req,\n    type: media.type,\n    state: media.state\n  }\n\n  console.log('resolving playlist', ctx)\n\n  const fn = compose(middlewares)\n  const result = (await fn(ctx)) || ctx.res\n  return finalizeMedia(result)\n}\n"],"sourceRoot":""}